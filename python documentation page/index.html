<!DOCTYPE html>
<html lang='en'>
  <head>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'>
    <meta charset='UTF-8'>
    <link rel='stylesheet' href='styles.css'>
    <title>Python documentation page</title>
  </head>
  <body>
    <nav id='navbar'>
        <header>Python Documentation</header>
        <a href="#Introduction" class="nav-link">Introduction</a>
        <a href="#What_you_already_know" class="nav-link">What you already know</a>
        <a href="#First_Python_program" class="nav-link">First Python program</a>
        <a href="#Variables" class="nav-link">Variables</a>
        <a href="#Loops" class="nav-link">Loops</a>
        <a href="#Data_types" class="nav-link">Data types</a>
        <a href="#if_statements" class="nav-link">If statements</a>
        <a href="#Functions" class="nav-link">Functions</a>
      </nav>
    <main id='main-doc'>
      <section class='main-section' id='Introduction'>
        <header>Introduction</header>
        <p>Python is a high-level, interpreted, interactive and object-oriented scripting language. Python is designed to be highly readable. It uses English keywords frequently where as other languages use punctuation, and it has fewer syntactical constructions than other languages.</p>
        <p>Python's features include:</p>
        <ul>
          <li>Easy-to-learn - Python has few keywords, simple structure, and a clearly defined syntax. This allows the student to pick up the language quickly.</li>
          <li>Easy-to-read - Python code is more clearly defined and visible to the eyes.</li>
          <li>A broad standard library - Python's bulk of the library is very portable and cross-platform compatible on UNIX, Windows, and Macintosh.</li>
          <li>GUI Programming - Python supports GUI applications that can be created and ported to many system calls, libraries and windows systems, such as Windows MFC, Macintosh, and the X Window system of Unix.</li>
        </ul>
      </section>
      <section class='main-section' id='What_you_already_know'>
        <header>What you already know</header>
        <p>This guide assumes you have the following basic background:</p>
        <ul>
          <li>A general understanding of the Internet and the World Wide Web (WWW).</li>
          <li>Some programming experience. If you are new to programming, try one of the tutorials linked on the main page about Python.</li>
        </ul>
      </section>
      <section class='main-section' id='First_Python_program'>
        <header>First Python Program</header>
        <p>Let us execute a Python "Hello, World!" Programs in different modes of programming.</p>
        <p>We can invoke a Python interpreter from command line by typing <span class="bold">python</span> at the command prompt as following −</p>
        <code>$ python
          Python 3.6.8 (default, Sep 10 2021, 09:13:53)
          [GCC 8.5.0 20210514 (Red Hat 8.5.0-3)] on linux
          Type "help", "copyright", "credits" or "license" for more information.
          >>></code>
          <p>Here >>> denotes a Python Command Prompt where you can type your commands. Let's type the following text at the Python prompt and press the Enter -</p>
          <code>>>> print ("Hello, World!")</code>
          <p>If you are running older version of Python, like Python 2.4.x, then you would need to use print statement without parenthesis as in print "Hello, World!". However in Python version 3.x, this produces the following result -</p>
          <code>Hello, World!</code>
      </section>
      <section class='main-section' id='Variables'>
        <header>Variables</header>
        <p>Python variables are the reserved memory locations used to store values with in a Python Program. This means that when you create a variable you reserve some space in the memory.</p>
        <p>Based on the data type of a variable, Python interpreter allocates memory and decides what can be stored in the reserved memory. Therefore, by assigning different data types to Python variables, you can store integers, decimals or characters in these variables.</p>
        <p><span class="subtitle">Creating Python Variables</span></p>
        <p>Python variables do not need explicit declaration to reserve memory space or you can say to create a variable. A Python variable is created automatically when you assign a value to it. The equal sign (=) is used to assign values to variables.
          The operand to the left of the '=' operator is the name of the variable and the operand to the right of the = operator is the value stored in the variable. For example -</p>
        <code>counter = 100 #Creates an integer variable</code>
        <code>miles = 1000.0 #Creates a floating point variable</code>
        <code>name = "Zara Ali" # Creates a string variable</code>
        <p><span class="subtitle">Printing Python Variables</span></p>
        <p>Once we create a Python variable and assign a value to it, we can print it using print() function. Following is the extension of previous example and shows how to print different variables in Python:
        </p>
        <code>counter = 100       # Creates an integer variable <br>
          miles   = 1000.0       # Creates a floating point variable <br>
          name    = "Zara Ali"   # Creates a string variable <br>
          print (counter) <br>
          print (miles) <br>
          print (name) <br></code>
        <p>Here, 100, 1000.0 and "Zara Ali" are the values assigned to counter, miles, and name variables, respectively. When running the above Python program, this produces the following result -</p>
        <code>100</code>
        <code>1000.0</code>
        <code>Zara Ali</code>
      </section>
      <section class='main-section' id='Loops'>
        <header>Loops</header>
        <p>In general, statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on. There may be a situation when you need to execute a block of code several number of times.</p>
        <p>Programming languages provide various control structures that allow for more complicated execution paths.</p>
        <p>A loop statement allows us to execute a statement or group of statements multiple times. The following diagram illustrates a loop statement -</p>
        <img src="diagram.jpg" alt="a diagram showing the sequence of a function in python">
        <p>Python programming language provides following types of loops to handle looping requirements.</p>
        <ul>
          <li>While loop</li>
          <li>For loop</li>
        </ul>
        <p>You will find that the for loop is by far the most popular of the two. Loops are used when you want to do something many times. Usually you will find that you need to do some operation or a set of operations on a piece of data over and over. This is where loops come in. They make it really easy to apply this sort of logic to your data.</p>
        <p>Let's get started learning how these fun structures work!</p>
        <p><span class="subtitle">The for loop</span></p>
        <p>As mentioned above, you use a loop when you want to iterate over something n number of times. It’s a little easier to understand if we see an example. Let’s use Python’s builtin range function. The range function will create a list that is n in length. In Python 2.x, there is actually another function called xrange that is a number generator and isn’t as resource intensive as range. They basically changed xrange into range in Python 3. Here is an example:</p>
        <code>>>> range(5) <br>
          range(0, 5)</code>
        <p>As you can see, the range function above took an integer and returned a range object. The range function also accepts a beginning value, an end value and a step value. Here are two more examples:</p>
        <code>>>> range(5,10) <br>
          range(5, 10) <br>
          >>> list(range(1, 10, 2)) <br>
          [1, 3, 5, 7, 9]</code>
        <p>The first example demonstrates that you can pass a beginning and end value and the range function will return the numbers from the beginning value up to but not including the end value. So in the case of 5-10, we get 5-9. The second example shows how to use the list function to cause the range function to return every second element between 1 and 10. So it starts with one, skips two, etc. Now you’re probably wondering what this has to do with loops. Well one easy way to show how a loop works is if we use the range function! Take a look:</p>
        <code>>>> for number in range(5): <br>
              print(number) <br> 
              0 <br>
              1 <br>
              2 <br>
              3 <br>
              4 <br></code>
        <p>
          What happened here? Let’s read it from left to right to figure it out. For each number in a range of 5, print the number. We know that if we call range with a value of 5, it will return a list of 5 elements. So each time through the loop, it prints out each of the elements. The for loop above would be the equivalent of the following:
        </p>
        <code>
          >>> for number in [0, 1, 2, 3, 4]: <br>
       print(number)
        </code>
        <p>
          The range function just makes it a little bit smaller. The for loop can loop over any kind of Python iterator. We’ve already seen how it can iterate over a list. Let’s see if it can also iterate over a dictionary.
        </p>
        <code>
          >>> a_dict = {"one":1, "two":2, "three":3} <br>
          >>> for key in a_dict: <br>
                print(key) <br>
          three <br>
          two <br>
          one
        </code>
        <p>
          When you use a for loop with a dictionary, you’ll see that it automatically loops over the keys. We didn’t have to say for key in a_dict.keys() (although that would have worked too). Python just did the right thing for us. You may be wondering why the keys printed in a different order than they were defined in the dictionary. As you may recall from chapter 3, dictionaries are unordered, so when we iterate over it, the keys could be in any order.
        </p>
        <p>
          Now if you know that the keys can be sorted, then you can do that before you iterate over them. Let’s change the dictionary slightly to see how that works.
        </p>
        <code>
          >>> a_dict = {1:"one", 2:"two", 3:"three"} <br>
          >>> keys = a_dict.keys() <br>
          >>> keys = sorted(keys) <br>
          >>> for key in keys: <br>
                print(key) <br>
          1 <br>
          2 <br>
          3 
        </code>
        <p>
          Let’s take a moment to figure out what this code does. First off, we create a dictionary that has integers for keys instead of strings. Then we extract the keys from the dictionary. Whenever you call the keys() method, it will return an unordered list of the keys. If you print them out and find them to be in ascending order, then that’s just happenstance. Now we have a view of the dictionary’s keys that are stored in a variable called keys. We sort it and then we use the for loop to loop over it.
        </p>
        <p>
          Now we’re ready to make things a little bit more interesting. We are going to loop over a range, but we want to print out only the even numbers. To do this, we want to use a conditional statement instead of using the range’s step parameter. Here’s one way you could do this:
        </p>
        <code>
          >>> for number in range(10): <br>
        if number % 2 == 0: <br>
            print(number) <br>
          0 <br>
          2 <br>
          4 <br>
          6 <br>
          8 
        </code>
        <p>You’re probably wondering what’s going on here. What’s up with the percent sign? In Python, the % is called a modulus operator. When you use the modulus operator, it will return the remainder. There is no remainder when you divide an even number by two, so we print those numbers out. You probably won’t use the modulus operator a lot in the wild, but I have found it useful from time to time.</p>
        <p>Now we’re ready to learn about the <span class="bold">While</span> loop.</p>
        <p><span class="subtitle">The while loop</span></p>
        <p>The while loop is also used to repeat sections of code, but instead of looping n number of times, it will only loop until a specific condition is met. Let’s look at a very simple example:</p>
        <code>
          >>> i = 0 <br>
>>> while i < 10: <br>
        print(i) <br>
        i = i + 1 
        </code>
        <p>
          The while loop is kind of like a conditional statement. Here’s what this code means: while the variable i is less than ten, print it out. Then at the end, we increase i’s value by one. If you run this code, it should print out 0-9, each on its own line and then stop. If you remove the piece where we increment i’s value, then you’ll end up with an infinite loop. This is usually a bad thing. Infinite loops are to be avoided and are known as logic errors.
        </p>
      </section>
      <section class='main-section' id='Data_types'>
        <header>Data types</header>
        <p>Python Data Types are used to define the type of a variable. It defines what type of data we are going to store in a variable. The data stored in memory can be of many types. For example, a person's age is stored as a numeric value and his or her address is stored as alphanumeric characters.</p>
        <p>
          Python has various built-in data types which we will discuss with in this tutorial:
        </p>
        <ul>
          <li>Numeric - int, float, complex</li>
          <li>String - str</li>
          <li>Sequence - list, tuple, range</li>
          <li>Binary - bytes, bytearray, memoryview</li>
          <li>Mapping - dict</li>
          <li>Boolean - bool</li>
          <li>Set - set, frozenset</li>
          <li>None - NoneType</li>
        </ul>
      </section>
      <section class='main-section' id='if_statements'>
        <header>if statements</header>
        <p>
          Decision making is anticipation of conditions occurring while execution of the program and specifying actions taken according to the conditions.
        </p>
        <p>
          Decision structures evaluate multiple expressions which produce TRUE or FALSE as outcome. You need to determine which action to take and which statements to execute if outcome is TRUE or FALSE otherwise.
        </p>
        <p>
          Following is the general form of a typical decision making structure found in most of the programming languages -
        </p>
        <img src="diagram2.jpg" alt="a diagram showing the flow of if statements and decision making in python">
        <p>Python programming language assumes any non-zero and non-null values as TRUE, and if it is either zero or null, then it is assumed as FALSE value</p>
        <p>Let us go through each decision making briefly -</p>
        <p><span class="subtitle">Single Statement Suites</span></p>
        <p>If the suite of an <span class="bold">if</span> clause consists only of a single line, it may go on the same line as the header statement.</p>
        <p>Here is an example of a one-line if clause -</p>
        <code>
          #!/usr/bin/python <br>
          var = 100 <br>
          if ( var == 100 ) : print "Value of expression is 100" <br>
          print "Good bye!"
        </code>
        <p>When the above code is executed, it produces the following result -</p>
        <code>
          Value of expression is 100 <br>
          Good bye!
        </code>
      </section>
      <section class='main-section' id='Functions'>
        <header>Functions</header>
        <p>
          A function is a block of organized, reusable code that is used to perform a single, related action. Functions provide better modularity for your application and a high degree of code reusing.
        </p>
        <p>
          As you already know, Python gives you many built-in functions like print(), etc. but you can also create your own functions. These functions are called user-defined functions.
        </p>
        <p><span class="subtitle">Defining a Function</span></p>
        <p>
          You can define functions to provide the required functionality. Here are simple rules to define a function in Python.
        </p>
        <ul>
          <li>Function blocks begin with the keyword <span class="bold">def</span> followed by the function name and parentheses ( ( ) ).</li>
          <li>Any input parameters or arguments should be placed within these parentheses. You can also define parameters inside these parentheses.</li>
          <li>The first statement of a function can be an optional statement - the documentation string of the function or docstring.</li>
          <li>he code block within every function starts with a colon (:) and is indented.</li>
          <li>The statement return [expression] exits a function, optionally passing back an expression to the caller. A return statement with no arguments is the same as return None.</li>
        </ul>
        <p><span class="subtitle">Syntax</span></p>
        <code>
          def functionname( parameters ): <br>
            "function_docstring" <br>
            function_suite <br>
            return [expression] <br>
        </code>
        <p>By default, parameters have a positional behavior and you need to inform them in the same order that they were defined.</p>
        <p><span class="subtitle">Example</span></p>
        <p>The following function takes a string as input parameter and prints it on standard screen.</p>
        <code>
          def printme( str ): <br>
            "This prints a passed string into this function" <br>
            print str <br>
            return <br>
        </code>
        <p><span class="subtitle">Calling a Function</span></p>
        <p>Defining a function only gives it a name, specifies the parameters that are to be included in the function and structures the blocks of code.</p>
        <p>Once the basic structure of a function is finalized, you can execute it by calling it from another function or directly from the Python prompt. Following is the example to call printme() function -</p>
      </section>
      <code>
        #!/usr/bin/python <br>

        # Function definition is here <br>
          def printme( str ): <br>
            "This prints a passed string into this function" <br>
            print str <br>
            return; <br>

        # Now you can call printme function <br>
        printme("I'm first call to user defined function!") <br>
        printme("Again second call to the same function")
      </code>
      <p>When the above code is executed, it produces the following result -</p>
      <code>
        I'm first call to user defined function! <br> 
        Again second call to the same function
      </code>
      <p><span class="subtitle">Pass by reference vs value</span></p>
      <p>
        All parameters (arguments) in the Python language are passed by reference. It means if you change what a parameter refers to within a function, the change also reflects back in the calling function. For example −
      </p>
      <code>
        #!/usr/bin/python <br>

      # Function definition is here <br>
      def changeme( mylist ):
          "This changes a passed list into this function" <br>
          mylist.append([1,2,3,4]); <br>
          print "Values inside the function: ", mylist <br>
          return <br>

      # Now you can call changeme function <br>
      mylist = [10,20,30]; <br>
      changeme( mylist ); <br>
      print "Values outside the function: ", mylist
      </code>
      <p>
        Here, we are maintaining reference of the passed object and appending values in the same object. So, this would produce the following result −
      </p>
      <code>
        Values inside the function:  [10, 20, 30, [1, 2, 3, 4]] <br>
        Values outside the function:  [10, 20, 30, [1, 2, 3, 4]]
      </code>
      <p>
        There is one more example where argument is being passed by reference and the reference is being overwritten inside the called function.
      </p>
      <code>
        #!/usr/bin/python <br>
      # Function definition is here <br>
      def changeme( mylist ): <br>
          "This changes a passed list into this function" <br>
          mylist = [1,2,3,4]; # This would assig new reference in mylist <br>
          print "Values inside the function: ", mylist <br>
          return <br>
      # Now you can call changeme function <br>
      mylist = [10,20,30]; <br>
      changeme( mylist ); <br>
      print "Values outside the function: ", mylist <br>
      </code>
      <p>
        The parameter mylist is local to the function changeme. Changing mylist within the function does not affect mylist. The function accomplishes nothing and finally this would produce the following result −
      </p>
      <code>
        Values inside the function:  [1, 2, 3, 4] <br>
        Values outside the function:  [10, 20, 30]
      </code>
      <p><span class="subtitle">Function Arguments</span></p>
      <p>You can call a function by using the following types of formal arguments −</p>
        <ul>
          <li>Required arguments</li>
          <li>Keyword arguments</li>
          <li>Default arguments</li>
          <li>Variable-length arguments</li>
        </ul>
      <p><span class="subtitle">Required arguments</span></p>
      <p>
        Required arguments are the arguments passed to a function in correct positional order. Here, the number of arguments in the function call should match exactly with the function definition.
      </p>
      <p>
        To call the function printme(), you definitely need to pass one argument, otherwise it gives a syntax error as follows −
      </p>
      <code>
        #!/usr/bin/python <br>
        # Function definition is here <br>
          def printme( str ): <br>
            "This prints a passed string into this function" <br>
            print str <br>
            return; <br>
        # Now you can call printme function <br>
        printme()
      </code>
      <p>
        When the above code is executed, it produces the following result −
      </p>
      <code>
        My string
      </code>
      <p>
        The following example gives more clear picture. Note that the order of parameters does not matter.
      </p>
      <code>
        #!/usr/bin/python <br>

        # Function definition is here <br>
        def printinfo( name, age ): <br>
            "This prints a passed info into this function" <br>
            print "Name: ", name <br>
            print "Age ", age <br>
            return; <br>

        # Now you can call printinfo function <br>
        printinfo( age=50, name="miki" ) <br>
      </code>
      <p>
        When the above code is executed, it produces the following result −
      </p>
      <code>
        Name:  miki <br>
        Age  50
      </code>
      <p><span class="subtitle">Default arguments</span></p>
      <p>
        A default argument is an argument that assumes a default value if a value is not provided in the function call for that argument. The following example gives an idea on default arguments, it prints default age if it is not passed −
      </p>
      <code>
        #!/usr/bin/python <br>

        # Function definition is here <br>
        def printinfo( name, age = 35 ): <br>
            "This prints a passed info into this function" <br>
            print "Name: ", name <br>
            print "Age ", age <br>
            return; <br>

        # Now you can call printinfo function <br>
        printinfo( age=50, name="miki" ) <br>
        printinfo( name="miki" ) 
      </code>
      <p>
        When the above code is executed, it produces the following result −
      </p>
      <code>
        Name:  miki <br>
        Age  50 <br>
        Name:  miki <br>
        Age  35 <br>
      </code>
      <p><span class="subtitle">Variable-length arguments</span></p>
      <p>
        You may need to process a function for more arguments than you specified while defining the function. These arguments are called variable-length arguments and are not named in the function definition, unlike required and default arguments.
      </p>
      <p>
        Syntax for a function with non-keyword variable arguments is this −
      </p>
      <code>
        def functionname([formal_args,] *var_args_tuple ): <br>
        "function_docstring" <br>
        function_suite <br>
        return [expression] 
      </code>
      <p>
        An asterisk (*) is placed before the variable name that holds the values of all nonkeyword variable arguments. This tuple remains empty if no additional arguments are specified during the function call. Following is a simple example −
      </p>
      <code>
        #!/usr/bin/python <br>

        # Function definition is here <br>
        def printinfo( arg1, *vartuple ): <br>
           "This prints a variable passed arguments" <br>
           print "Output is: " <br>
           print arg1 <br>
           for var in vartuple: <br>
              print var <br>
           return; <br>
        
        # Now you can call printinfo function <br>
        printinfo( 10 ) <br>
        printinfo( 70, 60, 50 )
      </code>
      <p>When the above code is executed, it produces the following result −</p>
      <code>
        Output is: <br>
        10 <br>
        Output is: <br>
        70 <br>
        60 <br>
        50       
      </code>
      <p><span class="subtitle">The <span class="italic">Anonymous</span> Functions</span></p>
      <p>These functions are called anonymous because they are not declared in the standard manner by using the def keyword. You can use the lambda keyword to create small anonymous functions.</p>
      <ul>
        <li>Lhambda forms can take any number of arguments but return just one value in the form of an expression. They cannot contain commands or multiple expressions.</li>
        <li>An anonymous function cannot be a direct call to print because lambda requires an expression</li>
        <li>Lambda functions have their own local namespace and cannot access variables other than those in their parameter list and those in the global namespace.</li>
        <li>Although it appears that lambda's are a one-line version of a function, they are not equivalent to inline statements in C or C++, whose purpose is by passing function stack allocation during invocation for performance reasons.</li>
      </ul>
      <p><span class="subtitle">Syntax</span></p>
      <p>The syntax of <span class="italic">lambda</span> functions contains only a single statement, which is as follows −</p>
      <code>
        lambda [arg1 [,arg2,.....argn]]:expression
      </code>
      <p>
        Following is the example to show how lambda form of function works -
      </p>
      <code>
        #!/usr/bin/python <br>

        # Function definition is here <br>
        sum = lambda arg1, arg2: arg1 + arg2; <br>
        
        # Now you can call sum as a function <br>
        print "Value of total : ", sum( 10, 20 ) <br>
        print "Value of total : ", sum( 20, 20 ) <br>
      </code>
      <p>When the above code is executed, it produces the following result −</p>
      <code>
        Value of total :  30 <br>
        Value of total :  40
      </code>
      <p><span class="subtitle">The <span class="italic">return</span> Statement</span></p>
      <p>The statement return [expression] exits a function, optionally passing back an expression to the caller. A return statement with no arguments is the same as return None.</p>
      <p>All the above examples are not returning any value. You can return a value from a function as follows −</p>
      <code>
        #!/usr/bin/python <br>

        # Function definition is here <br>
        def sum( arg1, arg2 ):
           # Add both the parameters and return them." <br>
           total = arg1 + arg2 <br>
           print "Inside the function : ", total <br>
           return total; <br>
        
        # Now you can call sum function <br>
        total = sum( 10, 20 ); <br>
        print "Outside the function : ", total  <br>
      </code>
      <p>
        When the above code is executed, it produces the following result −
      </p>
      <code>
        Inside the function :  30 <br>
        Outside the function :  30        
      </code>
      <p><span class="subtitle">Scope of Variables</span></p>
      <p>All variables in a program may not be accessible at all locations in that program. This depends on where you have declared a variable.</p>
      <p>The scope of a variable determines the portion of the program where you can access a particular identifier. There are two basic scopes of variables in Python −</p>
        <ul>
          <li>Global variables</li>
          <li>Local variables</li>
        </ul>
        <p>Variables that are defined inside a function body have a local scope, and those defined outside have a global scope.</p>
        <p>This means that local variables can be accessed only inside the function in which they are declared, whereas global variables can be accessed throughout the program body by all functions. When you call a function, the variables declared inside it are brought into scope. Following is a simple example −</p>
        <code>
          #!/usr/bin/python <br>

          total = 0; # This is global variable. <br>
          # Function definition is here <br>
          def sum( arg1, arg2 ): <br>
             # Add both the parameters and return them." <br>
             total = arg1 + arg2; # Here total is local variable. <br>
             print "Inside the function local total : ", total <br>
             return total; <br>
          
          # Now you can call sum function <br>
          sum( 10, 20 ); <br>
          print "Outside the function global total : ", total
        </code>
        <p>When the above code is executed, it produces the following result −</p>
        <code>
          Inside the function local total :  30 <br>
          Outside the function global total :  0
        </code>
    </main>
  </body>
</html>